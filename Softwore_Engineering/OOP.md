# 객체지향
현실 세계의 개체(Entity)를 하나의 객체(Object)로 만들어, 객체들을 조립해서 소프트웨어 작성.

* 구조적 기법의 문제점으로 인한 소프트웨어 위기의 해결책
    > 구조적 기법의 문제점: 유지보수 고려X, 개발 시작 이후 추가적인 요구사항에 대응 어려움, 재사용이 어려움
* 주요 구성 요소와 개념에 객체, 클래스, 캡슐화, 상속, 다형성이 있다.

### Object
데이터와 데이터 처리 함수를 묶어 놓은(캡슐화한) 하나의 소프트웨어 모듈.

* 데이터(=Attribute): 객체가 가지고 있는 정보
* 함수(=Method, Operation): 객체가 수행하는 기능. 객체가 갖는 데이터를 처리하는 알고리즘.
* 객체의 특징
    - State: 객체가 가질 수 있는 조건. 일반적으로 상태는 시간에 따라 변한다.
    - 행위: 객체가 반응할 수 있는 메시지의 집합. 객체는 행위의 특징을 나타낼 수 있다.
    - 객체는 일정한 기억장소를 가질 수 있다.

### Class
공통된 속성과 행위를 갖는 객체의 집합. 객체의 일반적인 타입을 의미한다.

* 클래스는 각각의 객체들이 갖는 속성과 연산을 정의하고 있는 **틀**이다.
* **인스턴스: 클래스에 속한 각각의 객체**. 클래스로부터 새로운 객체를 생성하는 것을 인스턴스화라고 한다.
* 동일 클래스에 속한 각각의 객체(인스턴스)들은 공통된 속성과 행위를 가지고 있으면서, 그 속성에 대한 정보가 서로 달라서 동일 기능을 하는 여러 가지 객체를 나타낸다.

### Encapsulation
데이터(속성, attribute)와 데이터를 처리하는 함수를 하나로 묶는 것.

* 캡슐화된 객체는 인터페이스를 제외한 세부 내용이 은폐(정보 은닉)되어 외부에서의 접근이 제한적이다. 따라서 외부 모듈의 변경으로 인한 파급 효과가 적다.
* 객체간 메시지를 주고받을 때 상대 객체의 세부 내용을 알 필요가 없으므로 인터페이스가 단순해진다.

### Inheritance
이미 정의된 상위 클래스의 모든 속성과 연산을 하위 클래스가 물려받는 것.

* 하위 클래스는 상위 클래스의 모든 속성과 연산을 자신의 속성으로 사용할 수 있다.
* 하위 클래스는 상속받은 속성과 연산 외에 새로운 속성과 연산을 첨가하여 사용할 수 있다.
* 소프트웨어의 재사용을 높이는 중요한 개념.
    > 다중 상속(Multiple Inheritance): 한 개의 클래스가 두 개 이상의 상위 클래스로부터 속성과 연산을 상속받는 것.

### Polymorphism(다형성)
메시지에 의해 객체(클래스)가 연산을 수행할 때 하나의 메시지에 대해 각각의 객체(클래스)가 가지고 있는 고유한 방법(특성)으로 응답할 수 있는 능력.

> '+' 연산자의 경우 숫자 클래스에서는 덧셈, 문자 클래스에서는 문자열의 연결 기능으로 사용된다.

## OOP의 특징
* Abstraction
    - 현실 세계에 있는 것을 프로그래밍 세계로 옮기는 법?
    - ex.현실세계 : 차를 어떻게 프로그래밍으로 표현할 것?
    - attribute: name, color, operation: 등을 담기 위한 틀 => **Class**
    - attribute(속성), operation(기능) 등이 실제 동작하기 위해서는 class가 data를 담고 있어야 한다. => **Instance화**
    - Class에 data를 어떻게 담지? 메모리 공간을 확보해야 할 텐데? => **생성자를 이용하여 초기화**
    - 생성자를 통해 object를 생성 가능하며, 여기에 값을 할당할 수 있다. => **Object란 class가 instance화 된 것**
* Encapsulation
* Inheritance(상속)
    - 자식 클래스를 호출하면 부모 클래스도 초기화된다. 따라서 자식 클래스에서 부모 클래스의 object를 사용할 수 있다.
* Poly morphism(다형성)
    - 메서드 다형성: overriding된 메서드 호출 재정의한 메서드 응답.
    - overriding: 부모의 메소드를 자식이 상속. 자식 메소드에서 부모메소드 재정의 가능.
    - Super(): 부모클래스를 대신하는 키워드.

## OOP와 Class
* self = this(JS 등)
    - 자기 자신을 나타내는 딕셔너리
    - 값이 없는 채로 있다가 생성자에 의해 호출되어 값을 할당받을 때 마다 다른 값을 받게 됨.
    - 객체는 Unique하다. 따라서 생성자가 불려질 때 마다 다른 객체가 생성된다.
    - 이름이 같은 두 객체를 생성해도 두 객체는 다른 객체.
* SQL
    - Structured Query Language
    - 각 DB을 하나의 랭귀지로 쿼리하기 위한 표준
    - 객체지향을 쓰는 이유: DB를 어떤것을 사용하든 접근 가능(재정의, 사용자 코드의 재사용 가능)
* Interface : method만 가지는 사용자 표준
    - 자식에서 기능을 구현한다.

## SOLID
* 객체지향 원칙
* [참고 링크](http://www.nextree.co.kr/p6960/)
* SRP: Single Responsibility Principle, 단일책임의 원칙
    - 작성된 클래스는 하나의 기능만 가지며 클래스가 제공하는 모든 서비스는 그 하나의 책임을 수행하는 데 집중되어 있어야 한다.
* OCP: Open Close Principle, 개방폐쇄의 원칙
    - 소프트웨어의 구성요소(컴포넌트, 클래스, 모듈, 함수)는 확장에는 열려있고, 변경에는 닫혀있어야 한다.
    - 변경을 위한 비용은 가능한 줄이고 확장을 위한 비용은 극대화해야한다.
        - 요구사항의 변경이나 추가사항이 발생하더라도, 기존 구성요소는 수정이 일어나지 말아야 하며, 기존 구성요소를 쉽게 확장해서 재사용할 수 있어야 한다.
    - OCP를 가능케 하는 주요 매커니즘은 추상화와 다형성이다.
        - OCP는 관리가능하고 재사용 가능한 코드를 만드는 기반이며, 객체지향의 장점을 극대화하는 기능이다.
        
***

## 모듈
* 모듈의 기능적 독립성: 모듈이 하나의 기능만을 수행. 다른 모듈과의 과도한 상호작용을 배제한다.
* 독립성은 결합도와 응집도에 의해 측정된다. 독립성을 높이려면 결합도는 약하게, 응집도는 강하게, 모듈의 크기는 작게 만들어야 한다.

### Coupling(결합도)
모듈 간에 상호 의존하는 정도. 두 모듈 사이의 연관 관계

* 결합도가 약할수록 품질이 높다.
* 자료(Data) 결합도 < 스탬프(Stamp) 결합도 < 제어(Control) 결합도 < 외부(External) 결합도 < 공통(Common) 결합도 < 내용(Content) 결합도

### Cohesion(응집도)
정보 은닉의 개념을 확장한 것으로, 명령이나 호출문 등 모듈 내부 요소들이 서로 관련되어 있는 정도. **모듈이 독립적인 기능으로 정의되어 있는 정도.**

* 응집도가 강할수록 품질이 높다.
* 기능적 응집도(Functional) > 순차적 응집도(Sequential) > 교환적 응집도(Communicatoin) > 절차적 응집도(Procedural) > 시간적 응집도(Temporal) > 논리적 응집도(Logical) > 우연적 응집도(Coincidental)

### Fan-In / Fan-Out
* Fan-in: 어떤 모듈을 호출하는 모듈의 수
* Fan-out: 어떤 모듈에 의해 제어/호출되는 모듈의 수
* 시스템의 복잡도를 최적화하려면 팬인은 높게, 팬아웃은 낮게 설계해야 한다.